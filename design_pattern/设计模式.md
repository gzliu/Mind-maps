# 设计原则

## 单一职责原则SRP（Single Responsibility Principle)

其实单一原则就是开发人员常说的“高内聚、低耦合”，他表示为应该有且仅有一个原因引起类的变更，一个类只负责一件事。在所有的设计模式中都遵循单一职责原则
+ 设计够用就行，只有当需求复杂，且变化频繁的场景需要考虑单一职责原则
+ "仅有一个原因引起变化"这本身就不好界定，需要有经验的开发人员才能很好的定义出来
+ 如果一个类有太多的因素导致它改变，那么后期将很难维护。最终导致程序的"脆弱"和"僵硬"。比如有时间一个Service类写了好几千行代码，此时就需要将这个类根据SRP拆分

```java
/**
  比如定义了一个会员接口，有注册、下单方法。这就违背了SRP原则。
  需要进行拆分
*/
public interface IMember {
  // 注册
  public void register();
  // 下单
  public void createOrder();
}

/**
拆分后如下
*/

public interface IMember{
	public void register();
}

public interface IOrder{
	public void createOrder();
}
```


## 里氏替换原则

只要父类能出现的地方子类就可以出现，而且 替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但 是，反过来就不行了，有子类出现的地方，父类未必就能适应。

基本上就是Java实现接口的规范了：

1. 子类必须完全实现父类
2. 子类可以有自己的特性方法
3. 覆写或实现父类的方法时输出结果可以被缩小
4. 覆写或实现父类的方法，参数可以扩展

## 开闭原则

对扩展开放，对修改关闭。

最浅显的理解为：如果需要修改逻辑或者增加逻辑，应该通过实现父类方法或者继承父类方法进行实现，而不是在原有的代码中去做修改。

简单工厂模式是不符合开闭原则的

## 依赖倒置原则

简单来说就是“面向接口编程”

1. 高层模块不应该依赖底层模块，两者都应该依赖其抽象

1. 抽象不应依赖细节

1. 细节依赖抽象

底层模块：每个单独的原子逻辑

高层模块：多个原子逻辑组合在一起的就是高层模块

抽象对于java来说就是抽象类或者是接口，无法通过正常的new产生的类

细节就是实现抽象类或者继承接口的类，也就是可以通过new创建的类

## 接口隔离原则

接口应尽量的详细。主要是从实现代码层面来划分

## 迪米特法则

最少知原则。一个类对自己耦合的类或调用的类知道最少。

# 工厂模式



# 单例模式







